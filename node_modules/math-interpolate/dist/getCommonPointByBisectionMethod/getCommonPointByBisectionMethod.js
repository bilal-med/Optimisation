"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getCommonPointByBisectionMethod = void 0;
exports.getCommonPointByBisectionMethod = function (_a) {
    var fn1 = _a.fn1, fn2 = _a.fn2, _b = _a.xMin, xMin = _b === void 0 ? -1000 : _b, // Левый конец отрезка
    _c = _a.xMax, // Левый конец отрезка
    xMax = _c === void 0 ? 1000 : _c, // Правый конец отрезка
    _d = _a.eps, // Правый конец отрезка
    eps = _d === void 0 ? 0.001 : _d, // Требуемая точность
    _e = _a.iMax, // Требуемая точность
    iMax = _e === void 0 ? 1000 : _e;
    var a = xMin;
    var b = xMax;
    // const fn1 = x => (line1Coeffs.k * x) + line1Coeffs.b;
    var diffFn = function (x) { return fn1(x) - fn2(x); };
    var counter = 0; // Счётчик итераций
    var middle = 0.0; // Переменная для вычисления середины отрезка
    if (Math.sign(diffFn(a)) * Math.sign(diffFn(b)) > 0) {
        return {
            error: true,
            descriptrion: 'diffFn(x) имеет одинаковый знак на границах отрезка',
        };
    }
    while (Math.abs(b - a) > eps) {
        middle = (a + b) / 2; // Середина между a и b
        // корень лежит в левой половине отрезка
        if (Math.sign(diffFn(a)) * Math.sign(diffFn(middle)) <= 0) {
            b = middle; // Сдвигаем правую границу отрезка в середину
        }
        else {
            a = middle; // Сдвигаем левую границу отрезка в середину
        }
        if (++counter === iMax) {
            return {
                error: true,
                descriptrion: 'Превышено максимально допустимое количество итераций',
            };
        }
    }
    // Успех, корень лежит где внутри отрезка [a, b], который имеет длину меньше eps
    return {
        error: false,
        x: (a + b) / 2,
        y: fn1((a + b) / 2),
    };
};
